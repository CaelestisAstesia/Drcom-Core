# 协议详解 Dr.COM 5.2.0 D

## 1. Challenge 阶段 (Code 0x01, 0x02)

**目的:** Challenge 阶段是整个认证流程的第一步。它的核心目的是从 Dr.COM 认证服务器获取一个动态的、一次性的 4 字节数据，称为 "Salt" (盐值)。这个 Salt 将在随后的 Login 阶段中被用来加密（严格来说是参与 MD5 哈希计算）用户的密码，从而防止针对静态密码的重放攻击。

这个阶段包含一次请求和一次响应。

### 1.1 客户端请求 (Code: 0x01)

客户端（`Drcom-Core`）向服务器的 UDP 61440 端口发送一个 20 字节的数据包，发起挑战请求。

| 偏移量 (字节) | 长度 (字节) | 描述 | 值 (Hex) |
| :--- | :--- | :--- | :--- |
| 0-1 | 2 | 协议代码 | `01 02` |
| 2-3 | 2 | 随机数 | `XX XX` |
| 4 | 1 | 后缀 | `09` |
| 5-19 | 15 | 填充 | `00 00 ... 00` |

* **协议代码 (`0x01 0x02`):** 固定的，标识这是一个 Challenge 请求。
* **随机数 (2 字节):** 客户端生成的一个随机数。在代码实现中，这个数通常由 `time.time()` 加上一个小的随机整数 (`random.randint(0xF, 0xFF)`) 构成，然后取模 `0xFFFF` 并打包为 2 字节小端序 (`<H`)。
* **后缀 (`0x09`):** 固定值。
* **填充 (15 字节):** 固定的 `0x00` 填充。

具体代码参考 `src/drcom_protocol/challenge.py`。

### 1.2 服务器响应 (Code: 0x02)

服务器收到 `0x01` 请求后，会回复一个 UDP 包，其中包含了关键的 Salt。

| 偏移量 (字节) | 长度 (字节) | 描述 | 值 (Hex) |
| :--- | :--- | :--- | :--- |
| 0 | 1 | 协议代码 | `02` |
| 1 | 1 | 响应类型 | `01` |
| 2-3 | 2 | 随机数回显 | `XX XX` |
| **4-7** | **4** | **Salt (盐值)** | **`XX XX XX XX`** |
| 8-... | ... | 其他数据 (IP, 版本等) | ... |

* **协议代码 (`0x02`):** 固定的，标识这是一个 Challenge 响应。
* **Salt (4 字节):** 这是 Challenge 阶段的**核心目标**。它位于数据包的第 4 到第 7 字节 (索引从 0 开始)。

具体代码参考 `src/drcom_protocol/challenge.py`。


## 2. Login 阶段 (Code 0x03, 0x04, 0x05)

**目的:**

在 Challenge 阶段成功获取到 4 字节的 Salt 后，客户端立即进入 Login 阶段。此阶段的目的是**发送认证包**，包中包含了用户名、经过 Salt 加密的密码、MAC 地址、IP 地址、主机名等信息，以供服务器校验。

服务器会响应该请求，返回 `0x04` (成功) 或 `0x05` (失败)。

### 2.1 客户端请求 (Code: 0x03)

客户端发送一个包含完整认证信息的 UDP 包。这是一个结构复杂的包，总长度取决于用户名长度，通常在 330 字节左右。

* **数据包结构 (D 版 5.2.0D):**

| 偏移量 (字节) | 长度 (字节) | 描述 | 值 (Hex) |
| :--- | :--- | :--- | :--- |
| 0-1 | 2 | 协议代码 | `03 01` |
| 2 | 1 | 包类型 | `00` |
| 3 | 1 | 包长度 | `LL` |
| 4-19 | 16 | **MD5A** | `XX ... XX` |
| 20-55 | 36 | 用户名 | `XX ... XX` |
| 56 | 1 | ControlCheckStatus | `20` (通常) |
| 57 | 1 | AdapterNum | `XX` (可配置) |
| 58-63 | 6 | MAC 地址异或 MD5A | `XX ... XX` |
| 64-79 | 16 | **MD5B** | `XX ... XX` |
| 80 | 1 | IP 地址数量 | `01` |
| 81-84 | 4 | 本机 IP (Host IP) | `XX XX XX XX` |
| 85-96 | 12 | IP 地址填充 | `00 ... 00` |
| 97-104 | 8 | **MD5C (Checksum 1)** | `XX ... XX` |
| 105 | 1 | IPDOG 标志 | `01` (通常) |
| 106-109 | 4 | IPDOG 分隔符 | `00 00 00 00` |
| 110-141 | 32 | 主机名 (Host Name) | `XX ... XX` |
| 142-145 | 4 | 主 DNS | `XX XX XX XX` |
| 146-149 | 4 | DHCP 服务器 | `XX XX XX XX` |
| 150-153 | 4 | 备 DNS | `00 00 00 00` |
| 154-161 | 8 | WINS 服务器 (填充) | `00 ... 00` |
| 162-309 | 148 | 操作系统信息 (版本, 标识等) | `XX ... XX` |
| 310-311 | 2 | 认证版本 (Auth Version) | `XX XX` (可配置) |
| 312-325 | 14 | **DrcomAuthExtData** (见下) | `XX ... XX` |
| 326 | 1 | 自动登出 | `00` |
| 327 | 1 | 广播模式 | `00` |
| 328-329 | 2 | 末尾标识 | `E9 13` (通常) |

* **关键计算字段:**
    * **MD5A (16 字节):** `MD5(b'\x03\x01' + Salt + Password)`。
    * **MAC 地址异或 (6 字节):** 客户端 MAC 地址 (整数) `XOR` MD5A 的前 6 字节 (转为整数)。
    * **MD5B (16 字节):** `MD5(b'\x01' + Password + Salt + b'\x00\x00\x00\x00')`。
    * **MD5C (Checksum 1) (8 字节):** `MD5(包数据[0:97] + b'\x14\x00\x07\x0b')`，取结果的前 8 字节。
    * **DrcomAuthExtData (14 字节):** 这是一个内嵌结构，包含 `Code (0x02)`、`Len (0x0c)`、一个 4 字节的 **Checksum2**、`Option (0x0000)` 和 6 字节的 MAC 地址。
        * **Checksum2 (CRC):** 一个自定义的 CRC 算法，计算 `包数据[0:312] + b'\x01\x26\x07\x11\x00\x00' + 6字节MAC地址`。

* **`Drcom-Core` 实现:**
    * 该数据包的构建逻辑位于 `src/drcom_protocol/login.py` 文件的 `build_login_packet` 函数中。
    * 相关的计算常量（如 MD5 前后缀、Checksum2 常量）位于 `src/drcom_protocol/constants.py`。

### 2.2 服务器响应 (Code: 0x04 - 成功)

如果认证成功，服务器返回 `0x04` 包。

* **数据包结构 (关键部分):**
| 偏移量 (字节) | 长度 (字节) | 描述 | 值 (Hex) |
| :--- | :--- | :--- | :--- |
| 0 | 1 | 协议代码 | `04` |
| ... | ... | ... | ... |
| **23-38** | **16** | **Auth Info (Tail)** | **`XX ... XX`** |

* **协议代码 (`0x04`):** 固定的，标识登录成功。
* **Auth Info (Tail) (16 字节):** 这是登录成功的**核心凭证**。它位于响应包的第 23 到 38 字节。这 16 字节将在后续的 **Keep Alive (心跳)** 阶段中被持续使用。

* **`Drcom-Core` 实现:**
    * 该响应包的解析逻辑位于 `src/drcom_protocol/login.py` 文件的 `parse_login_response` 函数中。
    * 该函数负责检查 `0x04` 代码，并从 `AUTH_INFO_START_INDEX` 提取 Auth Info。

### 2.3 服务器响应 (Code: 0x05 - 失败)

如果认证失败，服务器返回 `0x05` 包，并附带错误代码。

* **数据包结构 (关键部分):**
| 偏移量 (字节) | 长度 (字节) | 描述 | 值 (Hex) |
| :--- | :--- | :--- | :--- |
| 0 | 1 | 协议代码 | `05` |
| ... | ... | ... | ... |
| **4** | **1** | **错误代码** | **`XX`** |

* **协议代码 (`0x05`):** 固定的，标识登录失败。
* **错误代码 (1 字节):** 位于偏移量 4 处，标识失败的具体原因。常见错误代码包括：
    * `0x01`: 账号正在使用。
    * `0x03`: 账号或密码错误。
    * `0x04`: 余额不足。
    * `0x07`: IP 地址不匹配。
    * `0x0B`: MAC 地址不匹配。
    * `0x15`: 客户端版本不匹配。

* **`Drcom-Core` 实现:**
    * 该响应包的解析逻辑同样位于 `src/drcom_protocol/login.py` 文件的 `parse_login_response` 函数中。
    * 该函数负责检查 `0x05` 代码，并从 `ERROR_CODE_INDEX` 提取错误代码，用于日志记录和判断是否重试。


## 3. Keep Alive 阶段 (Code 0xFF, 0x07)

**目的:**

登录成功后，客户端必须**周期性地**（在 5.2.0D 版本中通常为 20 秒）向服务器发送心跳包 (Keep Alive)，以维持在线状态。如果服务器在规定时间内未收到心跳包，会强制T T户下线。

标准的 D 版心跳流程分为两个连续的部分：Keep Alive 1 (FF 包) 和 Keep Alive 2 (07 包序列)。

### 3.1 Keep Alive 1 (FF 包)

这是心跳周期的第一步。客户端发送一个 `0xFF` 包，服务器回复一个 `0x07` 包。

* **客户端请求 (Code: 0xFF)**

    客户端发送一个 40 字节的心跳包。

| 偏移量 (字节) | 长度 (字节) | 描述 | 值 (Hex) |
| :--- | :--- | :--- | :--- |
| 0 | 1 | 协议代码 | `FF` |
| 1-16 | 16 | **MD5** | `XX ... XX` |
| 17-19 | 3 | 填充 | `00 00 00` |
| 20-35 | 16 | **Auth Info (Tail)** | `XX ... XX` |
| 36-37 | 2 | 时间戳 | `XX XX` |
| 38-41 | 4 | 填充 | `00 00 00 00` |

* **协议代码 (`0xFF`):** 固定的，标识 Keep Alive 1。
* **MD5 (16 字节):** `MD5(b'\x03\x01' + Salt + Password)`。注意：这里的 `Salt` **不是**新获取的，而是沿用自 Login 阶段 `perform_login` 时使用的 `Salt`。
* **Auth Info (Tail) (16 字节):** 客户端在 Login 阶段从 `0x04` 响应包中获取的 16 字节凭证。
* **时间戳 (2 字节):** `int(time.time()) % 0xFFFF`，打包为 2 字节网络序 (`!H`)。

* **服务器响应 (Code: 0x07)**

    服务器仅回复一个 `0x07` 开头的包作为应答。客户端只需确认收到了 `0x07` 包，即可认为 Keep Alive 1 成功。

* **`Drcom-Core` 实现:**
    * `0xFF` 包的构建: `src/drcom_protocol/keep_alive.py` -> `build_keep_alive1_packet`。
    * `0x07` 响应的解析: `src/drcom_protocol/keep_alive.py` -> `parse_keep_alive1_response`。

---

### 3.2 Keep Alive 2 (07 包序列)

在 Keep Alive 1 成功后，客户端**立即**开始 Keep Alive 2 序列。这是一个由多个 `0x07` 包组成的复杂交互过程，用于同步客户端与服务器之间的状态。

* **关键概念: "Tail" (尾巴)**
    * `drcom-generic` 脚本 (如 `latest-wired.py`) 表明，`0x07` 序列中的**服务器响应包** (Server Response) 在偏移量 `[16:20]` 处包含一个 4 字节的动态值，`drcom-generic` 称之为 "tail"。
    * 这个 "tail" 必须被客户端提取，并用于构建**下一个发送的 `0x07` 请求包**，填充在请求包的 `[16:20]` 位置。
* **关键概念: "Number" (序列号)**
    * `0x07` 包在偏移量 1 处有一个 1 字节的序列号 (ID)。
    * 这个序列号由客户端维护，从 `0` 开始，每成功发送和接收一次 `0x07` 包（或在 `drcom-generic` 的某些实现中是每收到一次响应）就递增，并对 `0xFF` (255) 或 `0x7F` (127) 取模。`Drcom-Core` 中使用 `(x + 1) % 256`。

* **`Drcom-Core` 实现:**
    * `0x07` 包的构建: `src/drcom_protocol/keep_alive.py` -> `build_keep_alive2_packet`。
    * `0x07` 响应的解析 (提取 Tail): `src/drcom_protocol/keep_alive.py` -> `parse_keep_alive2_response`。

#### 3.2.1 07 包 - 初始化序列

根据 `drcom-generic` 和 `Drcom-Core` 的实现，首次 Keep Alive 2 会执行一个三步握手：

1.  **Packet 1 (Client -> Srv): Type 1 (First Packet)**
    * 客户端发送第一个 `0x07` 包，**Type=1**，`Number=0`，`Tail=b'\x00\x00\x00\x00'`。
    * 此包使用特殊的 `Version` 字段 `0x0F 27`。
    * 服务器回复 `0x07` 包。客户端**忽略**此响应中的 Tail。

2.  **Packet 2 (Client -> Srv): Type 1**
    * 客户端发送第二个 `0x07` 包，**Type=1**，`Number=1`，`Tail=b'\x00\x00\x00\x00'`。
    * 此包及后续包使用配置的 `KEEP_ALIVE_VERSION` (如 `0xDC 02`)。
    * 服务器回复 `0x07` 包。客户端**提取**此响应中的 4 字节 Tail (记为 `Tail 1`)。

3.  **Packet 3 (Client -> Srv): Type 3**
    * 客户端发送第三个 `0x07` 包，**Type=3**，`Number=2`，`Tail=Tail 1` (使用上一步获取的 Tail)。
    * Type 3 包在 `[28:32]` 偏移量处额外包含了客户端的 **Host IP**。
    * 服务器回复 `0x07` 包。客户端**提取**此响应中的 4 字节 Tail (记为 `Tail 2`)。

初始化序列完成，`Tail 2` 将作为稳定循环的起始 Tail。

#### 3.2.2 07 包 - 循环序列

在下一个心跳周期 (20 秒后)，客户端将执行 Keep Alive 1 (FF 包)，然后**立即**执行以下两步 07 包序列：

1.  **Packet (i) (Client -> Srv): Type 1**
    * 客户端发送 `0x07` 包，**Type=1**，`Number=i`，`Tail=Tail (N-1)` (使用上一个 `0x07` 响应中获取的 Tail)。
    * 服务器回复 `0x07` 包。客户端**提取**此响应中的 4 字节 Tail (记为 `Tail N`)。

2.  **Packet (i+1) (Client -> Srv): Type 3**
    * 客户端发送 `0x07` 包，**Type=3**，`Number=i+1`，`Tail=Tail N` (使用上一步获取的 Tail)。
    * 此包包含 Host IP。
    * 服务器回复 `0x07` 包。客户端**提取**此响应中的 4 字节 Tail (记为 `Tail N+1`)。

此 `Tail N+1` 将被用于下一个心跳周期的第一个 `0x07` 包 (Packet i)。


## 4. Logout 阶段 (Code 0x06)

**目的:**

Logout 阶段用于向服务器发送下线请求，主动终止网络会话。这是一个“尽力而为” (best-effort) 的操作。

根据 `drcom-generic` 的实现，客户端在发送 `0x06` 包之前，会**首先执行一次新的 Challenge (0x01, 0x02) 流程**，以获取一个**新的 Salt**。然后使用这个**新的 Salt** 来构建登出包。

### 4.1 客户端请求 (Code: 0x06)

客户端发送一个 `0x06` 包以请求登出。

* **数据包结构:**

| 偏移量 (字节) | 长度 (字节) | 描述 | 值 (Hex) |
| :--- | :--- | :--- | :--- |
| 0-1 | 2 | 协议代码 | `06 01` |
| 2 | 1 | 包类型 | `00` |
| 3 | 1 | 包长度 | `LL` |
| 4-19 | 16 | **MD5A (基于新 Salt)** | `XX ... XX` |
| 20-55 | 36 | 用户名 | `XX ... XX` |
| 56 | 1 | ControlCheckStatus | `20` (通常) |
| 57 | 1 | AdapterNum | `XX` (同登录) |
| 58-63 | 6 | MAC 地址异或 MD5A | `XX ... XX` |
| 64-79 | 16 | **Auth Info (Tail)** | `XX ... XX` |

* **协议代码 (`0x06 0x01`):** 固定的，标识这是一个 Logout 请求。
* **MD5A (16 字节):** `MD5(b'\x03\x01' + New_Salt + Password)`。**注意：** 这里的 `Salt` 是刚刚登出前新获取的，**不是**登录时用的 `Salt`。
* **MAC 地址异或 (6 字节):** 客户端 MAC 地址 `XOR` **新的** MD5A 的前 6 字节。
* **Auth Info (Tail) (16 字节):** 客户端在 **Login 阶段**从 `0x04` 响应包中获取的 16 字节凭证。这个是登出的关键凭证。

具体代码参考 `src/drcom_protocol/logout.py`。

### 4.2 服务器响应 (Code: 0x04 或无响应)

服务器在收到登出请求后的行为并不统一。

* **无响应:** 最常见的情况是，服务器收到 `0x06` 包后，**不返回任何响应**。客户端在短暂超时（如 2-3 秒）后 应视为登出成功。
* **成功响应 (`0x04`):** 在某些情况下，服务器可能会回复一个 `0x04` 包，明确表示登出成功。

* **`Drcom-Core` 实现:**
    * 响应的解析逻辑位于 `src/drcom_protocol/logout.py` 文件的 `parse_logout_response` 函数中。
    * 该函数会处理“无响应”（由 `socket.timeout` 触发）和收到 `0x04` 两种情况，均视为登出成功。
